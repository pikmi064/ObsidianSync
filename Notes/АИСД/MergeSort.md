## Алгоритм

**MergeSort** - алгоритм сортировки, основанный на принципе "разделяй и властвуй".

### Основные шаги:
1. **Разделение**: массив разбивается на две примерно равные части
2. **Рекурсия**: каждая часть рекурсивно сортируется
3. **Слияние**: отсортированные части объединяются в один массив

## Реализация на C++ (статические массивы)

```cpp
#include <iostream>
using namespace std;

// Функция слияния двух отсортированных массивов
void merge(int arr[], int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    
    // Создаем временные массивы
    int L[n1], R[n2];
    
    // Копируем данные во временные массивы
    for (int i = 0; i < n1; i++)
        L[i] = arr[left + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[mid + 1 + j];
    
    // Слияние временных массивов обратно в arr[left..right]
    int i = 0, j = 0, k = left;
    
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }
    
    // Копируем оставшиеся элементы L[]
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }
    
    // Копируем оставшиеся элементы R[]
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

// Рекурсивная функция MergeSort
void mergeSort(int arr[], int left, int right) {
    if (left >= right) return;
    
    int mid = left + (right - left) / 2;
    
    // Рекурсивно сортируем две половины
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    
    // Сливаем отсортированные половины
    merge(arr, left, mid, right);
}

// Вспомогательная функция для вывода массива
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++)
        cout << arr[i] << " ";
    cout << endl;
}

// Пример использования
int main() {
    int arr[] = {12, 11, 13, 5, 6, 7};
    int arr_size = sizeof(arr) / sizeof(arr[0]);
    
    cout << "Исходный массив: ";
    printArray(arr, arr_size);
    
    mergeSort(arr, 0, arr_size - 1);
    
    cout << "Отсортированный массив: ";
    printArray(arr, arr_size);
    
    return 0;
}
```

## Асимптотическая сложность

### Временная сложность:
- **Худший случай**: O(n log n)
- **Лучший случай**: O(n log n)  
- **Средний случай**: O(n log n)

### Пространственная сложность:
- **Дополнительная память**: O(n) - для временных массивов

## Доказательство временной сложности

### 1. Через мастер-теорему

Рекуррентное соотношение для MergeSort:
```
T(n) = 2T(n/2) + O(n)
```

Применяем мастер-теорему:
- a = 2 (количество подзадач)
- b = 2 (коэффициент уменьшения)
- f(n) = O(n) (время на разделение и слияние)

Сравниваем f(n) с n^(log_b a) = n^(log₂ 2) = n¹ = n

Поскольку f(n) = Θ(n), попадаем во **второй случай** мастер-теоремы:
```
T(n) = Θ(n log n)
```

### 2. Без мастер-теоремы

Рассмотрим дерево рекурсии:

```
Уровень 0: работа = n
Уровень 1: 2 подзадачи × работа n/2 = n
Уровень 2: 4 подзадачи × работа n/4 = n
...
Уровень k: 2^k подзадач × работа n/2^k = n
```

Количество уровней: log₂ n (так как на каждом уровне размер уменьшается вдвое)

Общая работа: количество уровней × работа на уровне = n × log₂ n

Таким образом: T(n) = O(n log n)

## Анализ использования памяти

### Основная память:
- **Исходный массив**: O(n)
- **Временные массивы**: O(n) (на каждом уровне рекурсии, но память освобождается)
### Стек вызовов:
- Глубина рекурсии: O(log n)
- Каждый вызов хранит константное количество данных (указатели)

**Итоговая пространственная сложность**: O(n)

## Особенности MergeSort

- Стабильная временная сложность O(n log n) во всех случаях
- Устойчивая сортировка (сохраняет порядок равных элементов)
- Требует дополнительной памяти O(n)
- Не адаптивная (не ускоряется на частично отсортированных данных)

