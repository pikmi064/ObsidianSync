## Идея алгоритма

Алгоритм разделяет массив на **отсортированную** (в начале) и **неотсортированную** части. На каждом шаге он берёт первый элемент из неотсортированной части и вставляет его в правильную позицию внутри отсортированной, сдвигая элементы при необходимости.

## Реализация на C++

``` c++
#include <vector>
using namespace std;

void insertionSort(vector<int>& arr) {
    int n = arr.size();
    
    // Начинаем со второго элемента (i = 1)
    for (int i = 1; i < n; ++i) {
        int key = arr[i]; // Элемент для вставки
        int j = i - 1;    // Индекс последнего элемента отсортированной части

        // Сдвигаем элементы, большие key, вправо
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        
        // Вставляем key в найденную позицию
        arr[j + 1] = key;
    }
}
```

## Свойства

- **Сложность по времени:**
    
    - **Худший случай:** `O(n²)` (обратно отсортированный массив)
        
    - **Лучший случай:** `Ω(n)` (уже отсортированный массив)
        
- **Сложность по памяти:** `O(1)` (in-place)

---

## Доказательство корректности методом инварианта цикла

**Инвариант цикла:** Перед каждой итерацией цикла `for` подмассив `arr[0..i-1]` отсортирован.

### Доказательство:

1. **Инициализация:**
    
    - При `i = 1` подмассив `arr[0..0]` из одного элемента отсортирован по определению
        
2. **Сохранение:**
    
    - Пусть перед итерацией `i = k` подмассив `arr[0..k-1]` отсортирован
        
    - Внутренний цикл `while` находит позицию `j + 1` для элемента `key = arr[k]`
        
    - После вставки `key` подмассив `arr[0..k]` становится отсортированным
        
    - Инвариант сохраняется для `i = k + 1`
        
3. **Завершение:**
    
    - При `i = n` согласно инварианту весь массив `arr[0..n-1]` отсортирован