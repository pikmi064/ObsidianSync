
---

#### **Принцип работы**
Быстрая сортировка основана на стратегии «разделяй и властвуй»:
1.  **Разбиение (Partition)**:
    *   Выбирается **опорный элемент** (pivot).
    *   Массив разбивается так, чтобы все элементы **меньше опорного** оказались слева, а **больше** — справа.
2.  **Рекурсивная сортировка**:
    *   Процесс повторяется для левой и правой частей массива.

---

#### **Псевдокод на C++ (Разбиение Ломуто)**
```cpp
// Функция для обмена элементов
void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

// Функция разбиения
int partition(int arr[], int low, int high) {
    int pivot = arr[high]; // опорный элемент
    int i = (low - 1); // индекс меньшего элемента

    for (int j = low; j <= high - 1; j++) {
        // Если текущий элемент меньше или равен опорному
        if (arr[j] <= pivot) {
            i++; // увеличиваем индекс меньшего элемента
            swap(&arr[i], &arr[j]);
        }
    }
    swap(&arr[i + 1], &arr[high]);
    return (i + 1);
}

// Основная функция быстрой сортировки
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        // pi - индекс разбиения, arr[pi] теперь на правильном месте
        int pi = partition(arr, low, high);

        // Рекурсивно сортируем элементы до и после разбиения
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}
```

---

#### **Разбиение Хоара (более эффективное)**
*   Опорный элемент часто выбирается из середины массива.
*   Два указателя (`i` и `j`) движутся навстречу друг другу.
*   Элементы, нарушающие порядок, меняются местами.
*   Эффективнее Ломуто: в среднем в 3 раза меньше обменов.

**Псевдокод на C++ (Хоара):**
```cpp
void quickSortHoare(int arr[], int low, int high) {
    if (low < high) {
        int i = low, j = high;
        int pivot = arr[(low + high) / 2]; // Выбор опоры из середины

        while (i <= j) {
            while (arr[i] < pivot) i++;
            while (arr[j] > pivot) j--;
            if (i <= j) {
                swap(&arr[i], &arr[j]);
                i++;
                j--;
            }
        }

        // Рекурсия
        if (low < j) quickSortHoare(arr, low, j);
        if (i < high) quickSortHoare(arr, i, high);
    }
}
```

---

#### **Оценка сложности**
| Случай  | Время          | Память       | Объяснение                                                                                                                              |
| :------ | :------------- | :----------- | :-------------------------------------------------------------------------------------------------------------------------------------- |
| Лучший  | $O(n \log n)$  | $O(\log n)$  | Массив всегда делится на две **равные или почти равные** части. Глубина рекурсии $\log n$, на каждом уровне работа $O(n)$.               |
| Средний | $O(n \log n)$  | $O(\log n)$  | Массив делится на части в **произвольном, но сбалансированном** соотношении (например, 1/10 и 9/10). Асимптотика остаётся $O(n \log n)$. |
| Худший  | $O(n^2)$       | $O(n)$       | Массив всегда делится на части **максимально несбалансированно** (например, 1 и n-1). Глубина рекурсии $n$, что приводит к $O(n^2)$.      |

*   **Худший случай**: возникает при consistently неудачном выборе опорного элемента (например, когда массив уже отсортирован, а опорный всегда выбирается с краю).
*   **Память**: зависит от глубины рекурсии. В худшем случае требуется $O(n)$ памяти в стеке для вызовов.

---

#### **Доказательство сложности (интуитивно)**
*   **Худший случай**:
    $$T(n) = T(n - 1) + O(n) = \sum_{k=1}^{n} O(k) = O(n^2)$$
    Рекурсия происходит по массиву размером `n-1`, а работа на каждом шаге — `O(n)`.
*   **Средний/Лучший случай**:
    $$T(n) = 2T\left(\frac{n}{2}\right) + O(n) = O(n \log n)$$
    Массив делится на две примерно равные части. Суммарная работа на каждом уровне рекурсии — $O(n)$, а уровней — $O(\log n)$.

---

#### **Устойчивость**
Быстрая сортировка **неустойчива**. Порядок одинаковых элементов может измениться во время процедуры разбиения (операции `swap`).

---

#### **Модификации**
1.  **Выбор опорного элемента**:
    *   **Случайный выбор**: `pivot = arr[low + rand() % (high - low + 1)]`. **На практике это основной способ избежать $O(n^2)$**.
    *   **Медиана трёх**: `pivot = median(arr[low], arr[mid], arr[high])`.
2.  **Оптимизация для малых массивов**:
    *   При размере подмассива < 10-20 используется сортировка вставками.
3.  **Хвостовая рекурсия**:
    *   Рекурсивный вызов делается только для меньшей части, чтобы уменьшить глубину стека.
    ```cpp
    void quickSortTailRecursion(int arr[], int low, int high) {
        while (low < high) {
            int pi = partition(arr, low, high);
            // Сначала сортируем меньшую часть
            if (pi - low < high - pi) {
                quickSortTailRecursion(arr, low, pi - 1);
                low = pi + 1;
            } else {
                quickSortTailRecursion(arr, pi + 1, high);
                high = pi - 1;
            }
        }
    }
    ```

---

#### **Преимущества и недостатки**
*   **+** Очень быстрая на практике (в среднем $O(n \log n)$), часто быстрее других алгоритмов.
*   **+** Сортировка на месте, требует мало дополнительной памяти ($O(\log n)$ в среднем).
*   **–** Неустойчивая.
*   **–** Худший случай $O(n^2)$ (решается случайным выбором опора).

---
